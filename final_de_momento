from pybit import WebSocket, HTTP
import win32api as pywin32

def set_leverage(lev, product, session_private):
    try:
        ret_msg = session_private.set_leverage(symbol=product, buy_leverage=lev, sell_leverage=lev)['ret_msg']
    except Exception as e:
        #pass
        ret_msg= e.message
    print('leverage:', lev, '-', ret_msg)

def get_trade_size(session_private, use_perc_balance, product="BTCUSDT", test=True):
    balance = session_private.get_wallet_balance()['result']['USDT']['available_balance']
    return math.floor(balance * use_perc_balance * lev / get_price(product=product, test=test)*1000)/1000

#-------------------------------------trading---------------------------
def put_order(session_private, product, pr, trade, quantity, order_type="Limit", dummy=True):
    if dummy:
        order_id = random.randint(0,10000)
    else:
        order_id = session_private.place_active_order(symbol=product, side=trade, order_type=order_type, qty=quantity, price=pr, time_in_force="GoodTillCancel", reduce_only=False, close_on_trigger=False)['result']['order_id']
    message = 'set ' + trade + ' ' + order_type + ' order of ' + str(quantity) + ' @ ' + str(pr)
    return order_id, message + ' - order_id:' +  str(order_id)

def cancel_order(session_private, order_id, dummy=True):
    if dummy:
        ret_msg = 'cancel dummy order - ' + str(order_id)
    else:
        msg = session_private.cancel_active_order(symbol=product,order_id=order_id)['ret_msg']
        ret_msg = 'cancel order ' +  str(order_id) + ' ' + msg
    return ret_msg

def check_positions(session_private, product, dummy=True):
    if dummy:
        if random.randint(0,1):
            return ''
        else:
            return 'some position'
    else:
        r = session_private.my_position(symbol=product)['result']
        return [p for p in (r if isinstance(r, list) else [r]) if p['size'] > 0]
    
def close_position(session_private, product, dummy=True):
    if dummy:
        return 'dummy position closed ' + product
    else:
        session_private.close_position(symbol=product)
        return 'position closed ' + product
#-------------------------------------------------------------------------------

def connect_session_private(api_key, api_secret, test=True):
    if test:
        url = 'https://api-testnet.bybit.com'
    else:
        url = 'https://api.bybit.com'
    return HTTP(endpoint=url, api_key=api_key, api_secret=api_secret, recv_window=50000)
    
def connect_ws_private(api_key, api_secret, test=True):
    if test:
        net = 'wss://stream-testnet.bybit.com/realtime_private'
    else:
        net = 'wss://stream.bybit.com/realtime_private'
    ws= WebSocket(endpoint=net,  subscriptions=['order', 'position'], api_key=api_key, api_secret=api_secret, ping_timeout=200, ping_interval=300, logging_level=0)
    return ws
        
def connect_session_public(test=True):
    if test:
        url = 'https://api-testnet.bybit.com'
    else:
        url = 'https://api.bybit.com'
    return HTTP(url)
    
def connect_ws_public(product="BTCUSDT", test=True):
    if test:
        net = 'wss://stream-testnet.bybit.com/realtime_public'
    else:
        net = 'wss://stream.bybit.com/realtime_public'
    subpr = "instrument_info.100ms."+product
    ws = WebSocket(endpoint=net, subscriptions=[subpr], ping_timeout=100, ping_interval=300, logging_level=0);
    return ws, subpr

def get_price_old(product="BTCUSDT", test=True):
    ws_public, subpr = connect_ws_public(product=product, test=test)
    pr =  float(pd.json_normalize(ws_public.fetch(subpr))['last_price'][0])
    ws_public.exit()
    return pr

def get_price_old2(product="BTCUSDT", test=True):
    ct = 0
    check1 = False
    while not check1:
        try:
            ws_public, subpr = connect_ws_public(product=product, test=test)
            time.sleep(0.05)
            dfpr = pd.json_normalize(ws_public.fetch(subpr))
            leng = len(dfpr.columns)
            while leng == 0:
                dfpr = pd.json_normalize(ws_public.fetch(subpr))
                leng = len(dfpr.columns)
                time.sleep(0.05)
                ct+=1
            ws_public.exit()
            pr = float(dfpr['last_price'][0])
            check1 = True
        except:
            time.sleep(0.05)
    return pr

def get_price(product="BTCUSDT", test=True):
    api_key = ''
    api_secret = ''
    session_private = connect_session_private(api_key, api_secret, test=False)
    price = session_private.orderbook(symbol="BTCUSDT")['result'][0]['price']
    while len(price)<1:
        price = session_private.orderbook(symbol="BTCUSDT")['result'][0]['price']
        time.sleep(0.05)
    session_private._exit()
    return float(price)

def get_latency(session_public):
    x = (dt.datetime.now() - datetime.datetime.fromtimestamp(float(session_public.server_time()['time_now'])))
    return (x.seconds + x.microseconds/1000000), round(time.time()-float(session_public.server_time()['time_now']),6)
        
def get_latency_adjust_seconds(session_public):
    lat = round(time.time()-float(session_public.server_time()['time_now']),6)
    if 1 > abs(lat) > 0.7:  
        return int(round(lat))
    elif abs(lat) > 1:
        return int(np.floor(lat))
    else: 
        return 0
    
def setsystime_seconds(secdelta):
    while not 60 > dt.datetime.now().second - secdelta > 0:
        time.sleep(0.3)
    t1 = dt.datetime.now()
    millisec = int(round((dt.datetime.now() - dt.datetime(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().day, dt.datetime.now().hour, dt.datetime.now().minute, 0)).microseconds / 1000))
    pywin32.SetSystemTime(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().weekday(), dt.datetime.now().day, dt.datetime.now().hour-1, dt.datetime.now().minute, dt.datetime.now().second - secdelta, millisec)
    return 'time changed '+ str(secdelta) + ' seconds from: ' + str(t1) + ' - to:' + str(dt.datetime.now())

def adjust_time_for_latency_seconds(session_public):
    secdelta = get_latency_adjust_seconds(session_public)
    if secdelta != 0:
        msg = setsystime_seconds(secdelta)
    else:
        msg = ''
    return msg

def adjust_time_for_latency(session_private):
    lat = int(round(time.time()-float(session_private.server_time()['time_now']), 3) * 1000)
    if abs(lat/1000) > 0.01:
        tchanged = False
        while not tchanged:
            try:
                snapsh = dt.datetime.now()
                millisec = int(round((snapsh - dt.datetime(snapsh.year, snapsh.month, snapsh.day, snapsh.hour, snapsh.minute, snapsh.second)).microseconds / 1000))
                newmillisec = snapsh.second*1000 + millisec - lat
                pywin32.SetSystemTime(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().weekday(), dt.datetime.now().day, dt.datetime.now().hour-1, 
                                      dt.datetime.now().minute, int(np.floor(newmillisec/1000)), int(newmillisec % 1000))
                tchanged = True
            except:
                pass
            msg = 'time changed '+ str(lat/1000) + ' seconds from: ' + str(snapsh) + ' - to:' + str(dt.datetime.now())
    else:
        msg = 'no time change, too small latency:' + str(lat/1000)
    return msg
    
def init_vals(product="BTCUSDT", test=True):
    return get_price(product=product, test=test), np.nan, 0, ''

def get_vola50sec(product="BTCUSDT", test=True):
    try:
        itime = dt.datetime.now()
        vola_ct = 0
        pr_vola = []
        while (dt.datetime.now() - itime).seconds < 45:
            pr_vola.append(get_price(product=product, test=test))
            vola_ct+=1
            time.sleep(1.5)
        vol1 = round((np.array(pr_vola)[1:] / np.array(pr_vola)[:-1]).std() * np.sqrt(365*24*60*30), 6)
        vol2 = round((np.array(pr_vola)[-3:] / np.array(pr_vola)[-4:-1]).std() * np.sqrt(365*24*60*30), 6)
        dif1 = round(abs(np.array(pr_vola)[1:] - np.array(pr_vola)[:-1]).mean(), 4)
        dif2 = round(abs(np.array(pr_vola)[-3:] - np.array(pr_vola)[-4:-1]).mean(), 4)
        dif3 = round((np.array(pr_vola)[-3:] - np.array(pr_vola)[-4:-1]).mean(), 4)
        volat = (dt.datetime.now() - itime).seconds
        x =  pd.DataFrame([[vol1, vol2, dif1, dif2, dif3, volat]], columns = ['vola_50sec','vola_6sec','dif_50sec','dif_6sec','dif_6sec_sign','vola_sec'])
    except:
        x = pd.DataFrame(columns = ['vola_50sec','vola_6sec','dif_50sec','dif_6sec','dif_6sec_sign','vola_sec'])
    return x

def get_price_diff(product="BTCUSDT", test=True):
    product="BTCUSDT"
    test=True

    try:
        itime = dt.datetime.now()
        vola_ct = 0
        pr_vola = []
        while (vola_ct < 5) and ((dt.datetime.now() - itime).seconds < 56):
            time.sleep(2)
            pr_vola.append(get_price(product=product, test=test))
            vola_ct+=1
        arrdif = np.array(pr_vola)[-(len(pr_vola)-1):] - np.array(pr_vola)[-len(pr_vola):-1]
        dif1 = round(abs(arrdif).mean(), 4)
        dif2 = round(arrdif.mean(), 4)
        dft = str(itime)[17:-4] + ' - ' + str(dt.datetime.now())[17:-4] + ' - ' + str(vola_ct)
        x =  pd.DataFrame([[dif1, dif2, dft]], columns = ['pr_diff','pr_diff_sign','dift'])
    except:
        x = pd.DataFrame(columns = ['pr_diff','pr_diff_sign','dift'])
    return x

def get_pr_buffer(close_pr, price_buffer_i, dfvola, flddelta='pr_diff'):
    price_buffer = price_buffer_i
    prdelta = price_buffer_i * close_pr
    if len(dfvola)>0:
        prdelta_ = max(dfvola[flddelta][0], 0.5)
        if close_pr * price_buffer_i > prdelta_ * 2:
            price_buffer = prdelta_ * 2 / close_pr
            prdelta = prdelta_ * 2
    return price_buffer, prdelta

def mean_rev_xper(session_private, conct_target, pr, prev_pr, prev_sign, prev_conct, trade_size, price_buffer, thresnull=0.00014, dummy=True):
    msg = ''
    trade=''
    order_id = 0
    conct = 1
    ret = (pr - prev_pr) / prev_pr
    ret = 0 if abs(ret) < thresnull else ret
    sign = 'pos' if ret > 0 else 'neg' if ret < 0 else ''
    
    if sign==prev_sign:
        conct = prev_conct+1
        if conct == conct_target and trade_size > 0:
            
            if sign=='neg':
                trade='Buy'
                order_id, msg = put_order(session_private, product, round((pr - price_buffer)*2)/2, trade=trade, quantity=trade_size, order_type='limit', dummy=dummy)
            elif sign=='pos':
                trade='Sell'
                order_id, msg = put_order(session_private, product, round((pr + price_buffer)*2)/2, trade=trade, quantity=trade_size, order_type='limit', dummy=dummy)    
        
    return trade, ret, pr, sign, conct, order_id, msg

#C:\ProgramData\Anaconda3\Lib

#-------------------------------------------------------------------

dummy = True
product="BTCUSDT"
lev = 3
use_perc_balance = 0.3

thresnull = 0.00015 #minimum not null return
conct_target = 3 #consecutive signs to trade
periods_in_trade = 2 #periods that trades is open
price_buffer_i = 1/10000
#trade_size = 0.001

api_name = 'der_rw_noip' #NO fixed IP (19-01-2022)
api_key = ''
api_secret = ''
permission = 'Contracts - Orders Positions'

mins = 15
test=False


dfr = pd.DataFrame()
dfvola = pd.DataFrame(columns = ['pr_diff','pr_diff_sign','dift'])
close_order_id = 0
ct = 0
ct_trade = 0
in_trade = 0
msg = []
position=True

#------------------------------------- logging--------------------------------    
locroot = 'C:/python_projects/' 
filename = 'bot_activity3_' + str(dt.datetime.today())[:10] + '.csv'
f = open(locroot + filename, "w")
fieldnames = ['ct','t','price','ret','sign','conct','trade', 'order_id','close_order_id','message','price_buffer','pr_diff','pr_diff_sign','dift']
f.write(';'.join([str(i) for i in fieldnames])+'\n')
f.close()
#------------------------------------------------------------------------------

print('starting time:', dt.datetime.now())
print('')

session_private = connect_session_private(api_key, api_secret, test=test)

prev_pr, prev_sign, prev_conct, trade = init_vals(product=product, test=test)

print(adjust_time_for_latency(session_private))
set_leverage(lev, product, session_private)
trade_size = get_trade_size(session_private, use_perc_balance)

while ct < 10000:

    timestamp1 = dt.datetime.now()
    
    if ((timestamp1.minute % mins == (mins - 1)) & (45 < timestamp1.second < 50)):
        print(ct)
        #adjust for latency and get trade size
        check1 = False
        while not check1:
            try:
                print(dt.datetime.now(), 'get trade size')
                trade_size = get_trade_size(session_private, use_perc_balance)
                check1 = True
            except:
                print('get trade size failed, reopening session..')
                session_private._exit()
                session_private = connect_session_private(api_key, api_secret, test=test)
                
        #get price change
        try:
            print(dt.datetime.now(), 'get price change')
            dfvola = get_price_diff()
        except:
            print('get price change failed')
            dfvola = pd.DataFrame(columns = ['pr_diff','pr_diff_sign'])
               
        
    if ((timestamp1.minute % mins == 0) & (timestamp1.second < 15)):
        print(dt.datetime.now(), 'evaluate')
                
        if ct_trade == periods_in_trade:
            check3 = False
            while not check3:
                try:
                    if not check_positions(session_private, product, dummy=dummy):
                        status = cancel_order(session_private, current_open_order_id)
                        msg.append(status)
                        in_trade = 0
                    else:
                        print('close trade')

                        close_pr = get_price(product=product, test=test)

                        price_buffer = get_pr_buffer(close_pr, price_buffer_i, dfvola, flddelta='pr_diff')[1]

                        if current_trade=='Buy':
                            close_order_id, msg_ = put_order(session_private, product, round((close_pr+price_buffer)*2)/2, trade='Sell', quantity=current_trade_size, order_type='limit', dummy=dummy)
                            msg.append(msg_)
                        elif current_trade=='Sell':
                            close_order_id, msg_ = put_order(session_private, product, round((close_pr-price_buffer)*2)/2, trade='Buy', quantity=current_trade_size, order_type='limit', dummy=dummy)   
                            msg.append(msg_)
                        current_close_order_id = close_order_id
                    check3 = True
                    
                except:
                    print('failed operate with' + str(periods_in_trade) + 'periods in trade')
                    session_private._exit()
                    session_private = connect_session_private(api_key, api_secret, test=test)
                    time.sleep(0.1)

        if ct_trade == periods_in_trade + 1:
            close_pr = np.nan
            check4 = False
            while not check4:
                try:
                    if check_positions(session_private, product, dummy=dummy):
                        status = cancel_order(session_private, current_close_order_id, dummy=dummy)
                        print(status)
                        msg.append(status)

                        print('close market position', current_open_order_id)
                        status = close_position(session_private, product, dummy=dummy) + ' - current_open_order_id: ' + str(current_open_order_id)
                        print(status)
                        msg.append(status)
                    check4 = True
                except:
                    print('failed operate with' + str(periods_in_trade+1) + 'periods in trade')
                    session_private._exit()
                    session_private = connect_session_private(api_key, api_secret, test=test)
                    time.sleep(0.1)

            in_trade = 0
            
        check5 = False
        while not check5:
            try:
                close_pr = get_price(product=product, test=test)
                price_buffer = get_pr_buffer(close_pr, price_buffer_i, dfvola, flddelta='pr_diff')[1]

                trade, ret, prev_pr, prev_sign, prev_conct, order_id, msg_ = mean_rev_xper(session_private, conct_target, close_pr, prev_pr, prev_sign, prev_conct, trade_size, price_buffer,
                                                                                           thresnull=thresnull, dummy=dummy)
                msg.append(msg_)
                check5=True

            except:
                print('failed evaluation')
                session_private._exit()
                session_private = connect_session_private(api_key, api_secret, test=test)
                time.sleep(0.1)

        if trade:
            in_trade = 1
            current_open_order_id = order_id
            current_trade = trade
            current_trade_size = trade_size

        msg = str(msg).replace('[','').replace(']','').replace("'","").replace(', ,','')
        msg = '' if msg == ', ' else msg
        dfr_ = pd.DataFrame([ct, dt.datetime.now(), prev_pr, ret, prev_sign, prev_conct, trade, order_id, close_order_id, msg, round(price_buffer,2)]).T
        dfr_.columns = ['ct','t','price','ret','sign','conct','trade', 'order_id','close_order_id','message','price_buffer']
        dfr_= pd.concat([dfr_, dfvola], axis=1)
        print(close_pr, prev_sign, prev_conct, trade, msg)
        
        f = open(locroot + filename, "a")
        f.write(';'.join([str(i) for i in list(dfr_.iloc[0])])+'\n')
        f.close()

        dfr = pd.concat([dfr, dfr_], axis=0)

        msg = []
        close_order_id = 0
        ct +=1
        ct_trade = (ct_trade+1)*in_trade
        time.sleep(15)
        
dfr.reset_index()
