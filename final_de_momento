from pybit import WebSocket, HTTP
import win32api as pywin32

def set_leverage(lev, product, session_private):
    try:
        ret_msg = session_private.set_leverage(symbol=product, buy_leverage=lev, sell_leverage=lev)['ret_msg']
    except Exception as e:
        #pass
        ret_msg= e.message
    print('leverage:', lev, '-', ret_msg)

def get_trade_size(session_private, use_perc_balance, product="BTCUSDT", test=True):
    balance = session_private.get_wallet_balance()['result']['USDT']['available_balance']
    return math.floor(balance * use_perc_balance * lev / get_price(product=product, test=test)*1000)/1000

#-------------------------------------trading---------------------------
def put_order(session_private, product, pr, trade, quantity, order_type="Limit", dummy=True):
    if dummy:
        order_id = random.randint(0,10000)
    else:
        order_id = session_private.place_active_order(symbol=product, side=trade, order_type=order_type, qty=quantity, price=pr, time_in_force="GoodTillCancel", reduce_only=False, close_on_trigger=False)['result']['order_id']
    message = 'set ' + trade + ' ' + order_type + ' order of ' + str(quantity) + ' @ ' + str(pr)
    return order_id, message + ' - order_id:' +  str(order_id)

def cancel_order(session_private, order_id, dummy=True):
    if dummy:
        ret_msg = 'cancel dummy order - ' + str(order_id)
    else:
        msg = session_private.cancel_active_order(symbol=product,order_id=order_id)['ret_msg']
        ret_msg = 'cancel order ' +  str(order_id) + ' ' + msg
    return ret_msg

def check_positions(session_private, product, dummy=True):
    if dummy:
        if random.randint(0,1):
            return ''
        else:
            return 'some position'
    else:
        r = session_private.my_position(symbol=product)['result']
        return [p for p in (r if isinstance(r, list) else [r]) if p['size'] > 0]
    
def close_position(session_private, product, dummy=True):
    if dummy:
        return 'dummy position closed ' + product
    else:
        session_private.close_position(symbol=product)
        return 'position closed ' + product
#-------------------------------------------------------------------------------

def connect_session_private(api_key, api_secret, test=True):
    if test:
        url = 'https://api-testnet.bybit.com'
    else:
        url = 'https://api.bybit.com'
    return HTTP(endpoint=url, api_key=api_key, api_secret=api_secret, recv_window=50000)
    
def connect_ws_private(api_key, api_secret, test=True):
    if test:
        net = 'wss://stream-testnet.bybit.com/realtime_private'
    else:
        net = 'wss://stream.bybit.com/realtime_private'
    ws= WebSocket(endpoint=net,  subscriptions=['order', 'position'], api_key=api_key, api_secret=api_secret, ping_timeout=200, ping_interval=300, logging_level=0)
    return ws
        
def connect_session_public(test=True):
    if test:
        url = 'https://api-testnet.bybit.com'
    else:
        url = 'https://api.bybit.com'
    return HTTP(url)
    
def connect_ws_public(product="BTCUSDT", test=True):
    if test:
        net = 'wss://stream-testnet.bybit.com/realtime_public'
    else:
        net = 'wss://stream.bybit.com/realtime_public'
    subpr = "instrument_info.100ms."+product
    ws = WebSocket(endpoint=net, subscriptions=[subpr], ping_timeout=100, ping_interval=300, logging_level=0);
    return ws, subpr

def get_price(product="BTCUSDT", test=True):
    api_key = 'ie9sHFzvNw0xNpkkgO'
    api_secret = 'VEv7ptCowmpS0oIpDP8O46YXKpvL7oNbGTLs'
    session_private = connect_session_private(api_key, api_secret, test=False)
    price = session_private.orderbook(symbol="BTCUSDT")['result'][0]['price']
    while len(price)<1:
        price = session_private.orderbook(symbol="BTCUSDT")['result'][0]['price']
        time.sleep(0.05)
    session_private._exit()
    return float(price)

def get_latency(session_public):
    x = (dt.datetime.now() - datetime.datetime.fromtimestamp(float(session_public.server_time()['time_now'])))
    return (x.seconds + x.microseconds/1000000), round(time.time()-float(session_public.server_time()['time_now']),6)
    
def setsystime_seconds(secdelta):
    while not 60 > dt.datetime.now().second - secdelta > 0:
        time.sleep(0.3)
    t1 = dt.datetime.now()
    millisec = int(round((dt.datetime.now() - dt.datetime(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().day, dt.datetime.now().hour, dt.datetime.now().minute, 0)).microseconds / 1000))
    pywin32.SetSystemTime(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().weekday(), dt.datetime.now().day, dt.datetime.now().hour-1, dt.datetime.now().minute, dt.datetime.now().second - secdelta, millisec)
    return 'time changed '+ str(secdelta) + ' seconds from: ' + str(t1) + ' - to:' + str(dt.datetime.now())

def adjust_time_for_latency(session_private):
    lat = int(round(time.time()-float(session_private.server_time()['time_now']), 3) * 1000)
    if abs(lat/1000) > 0.01:
        tchanged = False
        while not tchanged:
            try:
                snapsh = dt.datetime.now()
                millisec = int(round((snapsh - dt.datetime(snapsh.year, snapsh.month, snapsh.day, snapsh.hour, snapsh.minute, snapsh.second)).microseconds / 1000))
                newmillisec = snapsh.second*1000 + millisec - lat
                pywin32.SetSystemTime(dt.datetime.now().year, dt.datetime.now().month, dt.datetime.now().weekday(), dt.datetime.now().day, dt.datetime.now().hour-1, 
                                      dt.datetime.now().minute, int(np.floor(newmillisec/1000)), int(newmillisec % 1000))
                tchanged = True
            except:
                pass
            msg = 'time changed '+ str(lat/1000) + ' seconds from: ' + str(snapsh) + ' - to:' + str(dt.datetime.now())
    else:
        msg = 'no time change, too small latency:' + str(lat/1000)
    return msg
    
def init_vals(product="BTCUSDT", test=True):
    return get_price(product=product, test=test), np.nan, 0, ''


def get_price_diff(product="BTCUSDT", test=True):
    product="BTCUSDT"
    test=True

    try:
        itime = dt.datetime.now()
        vola_ct = 0
        pr_vola = []
        while (vola_ct < 5) and ((dt.datetime.now() - itime).seconds < 56):
            time.sleep(2)
            pr_vola.append(get_price(product=product, test=test))
            vola_ct+=1
        arrdif = np.array(pr_vola)[-(len(pr_vola)-1):] - np.array(pr_vola)[-len(pr_vola):-1]
        dif1 = round(abs(arrdif).mean(), 4)
        dif2 = round(arrdif.mean(), 4)
        dft = str(itime)[17:-4] + ' - ' + str(dt.datetime.now())[17:-4] + ' - ' + str(vola_ct)
        x =  pd.DataFrame([[dif1, dif2, dft]], columns = ['pr_diff','pr_diff_sign','dift'])
    except:
        x = pd.DataFrame(columns = ['pr_diff','pr_diff_sign','dift'])
    return x

def get_pr_buffer_dict(dfvola, maxbuffer, flddelta='pr_diff', fldsign='pr_diff_sign'):
    prdelta = dfvola[flddelta][0]
    sign = dfvola[fldsign][0]
    direct_dif = 1 if sign==0 else prdelta / abs(sign)
    if sign < 0:
        buffer_dict = {'Buy':min(prdelta+1.5, maxbuffer), 'Sell':min(1.5 * (direct_dif), maxbuffer)}
    else:
        buffer_dict = {'Buy':min(1.5 * direct_dif, maxbuffer), 'Sell':min(prdelta+1.5, maxbuffer)}
    return buffer_dict

def mean_rev_xper(session_private, conct_target, pr, prev_pr, prev_sign, prev_conct, trade_size, buffer_dict, thresnull=0.00014, dummy=True):
    msg = ''
    trade=''
    order_id = 0
    conct = 1
    ret = (pr - prev_pr) / prev_pr
    ret = 0 if abs(ret) < thresnull else ret
    sign = 'pos' if ret > 0 else 'neg' if ret < 0 else ''
    
    if sign==prev_sign:
        conct = prev_conct+1
        if conct == conct_target and trade_size > 0:
            
            if sign=='neg':
                trade='Buy'
                order_id, msg = put_order(session_private, product, round((pr - buffer_dict[trade])*2)/2, trade=trade, quantity=trade_size, order_type='limit', dummy=dummy)
            elif sign=='pos':
                trade='Sell'
                order_id, msg = put_order(session_private, product, round((pr + buffer_dict[trade])*2)/2, trade=trade, quantity=trade_size, order_type='limit', dummy=dummy)    
        
    return trade, ret, pr, sign, conct, order_id, msg

#C:\ProgramData\Anaconda3\Lib

#--------------------------------------------------------

dummy = True
product="BTCUSDT"
lev = 3
use_perc_balance = 0.3

thresnull = 0.00015 #minimum not null return
conct_target = 3 #consecutive signs to trade
periods_in_trade = 2 #periods that trades is open
price_buffer_i = 1/4000
#trade_size = 0.001

api_name = '' #NO fixed IP (19-01-2022)
api_key = ''
api_secret = ''
permission = 'Contracts - Orders Positions'

mins = 15
test=False


dfr = pd.DataFrame()
dfvola = pd.DataFrame(columns = ['pr_diff','pr_diff_sign','dift'])
close_order_id = 0
ct = 0
ct_trade = 0
in_trade = 0
todayday = 0
msg = []
position=True

print('starting time:', dt.datetime.now())
print('')

session_private = connect_session_private(api_key, api_secret, test=test)

prev_pr, prev_sign, prev_conct, trade = init_vals(product=product, test=test)

print(adjust_time_for_latency(session_private))
set_leverage(lev, product, session_private)
trade_size = get_trade_size(session_private, use_perc_balance)

while ct < 10000:

    timestamp1 = dt.datetime.now()
    
    if todayday != timestamp1.day:
        locroot = 'C:/python_projects/' 
        filename = 'bot_activity_' + str(dt.datetime.today())[:10] + '.csv'
        fieldnames = ['ct','t','price','ret','sign','conct','trade', 'order_id','close_order_id','message','buffer_dict','pr_diff','pr_diff_sign','dift']
        f.write(';'.join([str(i) for i in fieldnames])+'\n')
        f.close()
        todayday = timestamp1.day
    
    if ((timestamp1.minute % mins == (mins - 1)) & (45 < timestamp1.second < 50)):
        print(ct)
        #adjust for latency and get trade size
        check1 = False
        while not check1:
            try:
                print(dt.datetime.now(), 'get trade size')
                trade_size = get_trade_size(session_private, use_perc_balance)
                check1 = True
            except:
                print('get trade size failed, reopening session..')
                session_private._exit()
                session_private = connect_session_private(api_key, api_secret, test=test)
                
        #get price change
        try:
            print(dt.datetime.now(), 'get price change')
            dfvola = get_price_diff()
        except:
            print('get price change failed')
            dfvola = pd.DataFrame(columns = ['pr_diff','pr_diff_sign'])
               
        
    if ((timestamp1.minute % mins == 0) & (timestamp1.second < 15)):
        print(dt.datetime.now(), 'evaluate')
                
        if ct_trade == periods_in_trade:
            check3 = False
            while not check3:
                try:
                    if not check_positions(session_private, product, dummy=dummy):
                        status = cancel_order(session_private, current_open_order_id)
                        msg.append(status)
                        in_trade = 0
                    else:
                        print('close trade')

                        close_pr = get_price(product=product, test=test)
                        buffer_dict = get_pr_buffer_dict(dfvola, close_pr*price_buffer_i, flddelta='pr_diff', fldsign='pr_diff_sign')

                        if current_trade=='Buy':
                            close_order_id, msg_ = put_order(session_private, product, round((close_pr+buffer_dict[current_trade])*2)/2, trade='Sell', quantity=current_trade_size, order_type='limit', dummy=dummy)
                            msg.append(msg_)
                        elif current_trade=='Sell':
                            close_order_id, msg_ = put_order(session_private, product, round((close_pr-buffer_dict[current_trade])*2)/2, trade='Buy', quantity=current_trade_size, order_type='limit', dummy=dummy)   
                            msg.append(msg_)
                        current_close_order_id = close_order_id
                    check3 = True
                    
                except:
                    print('failed operate with' + str(periods_in_trade) + 'periods in trade')
                    session_private._exit()
                    session_private = connect_session_private(api_key, api_secret, test=test)
                    time.sleep(0.1)

        if ct_trade == periods_in_trade + 1:
            close_pr = np.nan
            check4 = False
            while not check4:
                try:
                    if check_positions(session_private, product, dummy=dummy):
                        status = cancel_order(session_private, current_close_order_id, dummy=dummy)
                        print(status)
                        msg.append(status)

                        print('close market position', current_open_order_id)
                        status = close_position(session_private, product, dummy=dummy) + ' - current_open_order_id: ' + str(current_open_order_id)
                        print(status)
                        msg.append(status)
                    check4 = True
                except:
                    print('failed operate with' + str(periods_in_trade+1) + 'periods in trade')
                    session_private._exit()
                    session_private = connect_session_private(api_key, api_secret, test=test)
                    time.sleep(0.1)

            in_trade = 0
            
        check5 = False
        while not check5:
            try:
                close_pr = get_price(product=product, test=test)
                buffer_dict = get_pr_buffer_dict(dfvola, close_pr*price_buffer_i, flddelta='pr_diff', fldsign='pr_diff_sign')

                trade, ret, prev_pr, prev_sign, prev_conct, order_id, msg_ = mean_rev_xper(session_private, conct_target, close_pr, prev_pr, prev_sign, prev_conct, trade_size, buffer_dict,
                                                                                           thresnull=thresnull, dummy=dummy)
                msg.append(msg_)
                check5=True

            except:
                print('failed evaluation')
                session_private._exit()
                session_private = connect_session_private(api_key, api_secret, test=test)
                time.sleep(0.1)

        if trade:
            in_trade = 1
            current_open_order_id = order_id
            current_trade = trade
            current_trade_size = trade_size

        msg = str(msg).replace('[','').replace(']','').replace("'","").replace(', ,','')
        msg = '' if msg == ', ' else msg
        dfr_ = pd.DataFrame([ct, dt.datetime.now(), prev_pr, ret, prev_sign, prev_conct, trade, order_id, close_order_id, msg, buffer_dict]).T
        dfr_.columns = ['ct','t','price','ret','sign','conct','trade', 'order_id','close_order_id','message','buffer_dict']
        dfr_= pd.concat([dfr_, dfvola], axis=1)
        print(close_pr, prev_sign, prev_conct, trade, msg)
        
        f = open(locroot + filename, "a")
        f.write(';'.join([str(i) for i in list(dfr_.iloc[0])])+'\n')
        f.close()

        dfr = pd.concat([dfr, dfr_], axis=0)

        msg = []
        close_order_id = 0
        ct +=1
        ct_trade = (ct_trade+1)*in_trade
        time.sleep(15)
        
dfr.reset_index()
